---
title: 'Exam Manipulation'
url: 'https://open.kattis.com/problems/exammanipulation'
author: 'Kattis'
tags: ['Bit Mask', 'Brute Force', 'Permutations'] 
languages: ['C++', 'Python3']
difficulty: medium
date: '2023-02-04'
---
This is problem seems tricky at first, but the constrained input size (up to 10 questions per test) allows us to simply use brute force to find a solution.
We can generate all possible answer keys and find which one renders the optimal score.
Keys are generated by counting up from 0 to 2^k, where k is the number of questions on the test.
Using the current count as a bit mask, we match its set bits against T's and unset bits against F's.
<CH.Code>

```cpp exam.cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <numeric>
using namespace std;
const int kMaxStudents = 1000;
const int kMaxQuestions = 10;
const int kMaxKeys = 1 << kMaxQuestions;

int withKey[kMaxStudents][kMaxKeys];
int worstScore[kMaxKeys];

int main() {
    int n,k;
    cin >> n >> k;
    const int kPossibleKeys = 1 << k;
    for (int i = 0; i < kPossibleKeys; ++i) {
        worstScore[i] = 11;
    }
    for (int i = 0; i < n; ++i) {
        string s;
        cin >> s;
        for (int key = 0; key < kPossibleKeys; ++key) {
            withKey[i][key] = 0; // initialize
            for (int question = 0; question < k; ++question) {
                bool trueOnKey = key & 1 << question;
                if ((s[question] == 'T' && trueOnKey) || (s[question] == 'F' && !trueOnKey)) {
                    withKey[i][key]++;                        
                }
            }
            worstScore[key] = min(worstScore[key], withKey[i][key]);
        } 
    }
    cout << *max_element(begin(worstScore), end(worstScore)) << '\n';
}
```


```py exam.py
n,k = map(int,input().split())
possible_keys = 1 << k
worst_score = [11 for _ in range(possible_keys)]
score_with_key = [[0 for _ in range(n)] for _ in range(possible_keys)]

best_worst = 0

for student in range(n):
    s = [c == 'T' for c in input()]
    for key in range(possible_keys):
        for q in range(k):
            expectation = key & 1 << q != 0
            score_with_key[key][student] += 1 if s[q] == expectation else 0
        worst_score[key] = min(worst_score[key], score_with_key[key][student])

print(max(worst_score))


















###
```

</CH.Code>
